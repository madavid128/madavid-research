#!/usr/bin/env python3
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2025 Michael A. David
"""
Export all site citations to a single BibTeX file.

The website stores publication data in `_data/citations.yaml` (generated by the
citation pipeline). Individual publication cards can already export per-item
BibTeX, but it is also useful to provide a single "download all" file for
reference managers.

This script reads `_data/citations.yaml` and writes a BibTeX file under
`downloads/` so it is served by Jekyll as a static file.
"""

from __future__ import annotations

import argparse
import hashlib
import re
from pathlib import Path

import yaml

REPO_ROOT = Path(__file__).resolve().parents[1]


def _slug(value: str) -> str:
    value = (value or "").strip().lower()
    value = re.sub(r"[^a-z0-9]+", "", value)
    return value or "citation"


def _year_from_date(value: str) -> str:
    value = (value or "").strip()
    m = re.search(r"(19|20)\d{2}", value)
    return m.group(0) if m else ""


def _bib_key(citation: dict) -> str:
    authors = citation.get("authors") or []
    first_author = ""
    if isinstance(authors, list) and authors:
        first_author = str(authors[0])
    last = _slug(first_author.split()[-1] if first_author else "")
    year = _year_from_date(str(citation.get("date", "")))
    ident = str(citation.get("id", "")) or str(citation.get("link", "")) or str(citation.get("title", ""))
    suffix = hashlib.sha1(ident.encode("utf-8")).hexdigest()[:6]
    parts = [p for p in [last, year, suffix] if p]
    return "_".join(parts) if parts else f"citation_{suffix}"


def _bib_escape(value: str) -> str:
    value = (value or "").strip()
    value = value.replace("{", "\\{").replace("}", "\\}")
    return value


def _to_bibtex(citation: dict) -> str:
    key = _bib_key(citation)
    title = _bib_escape(str(citation.get("title", "")))
    authors = citation.get("authors") or []
    if isinstance(authors, list):
        author_str = " and ".join(_bib_escape(str(a)) for a in authors)
    else:
        author_str = _bib_escape(str(authors))
    journal = _bib_escape(str(citation.get("publisher", "")))
    year = _year_from_date(str(citation.get("date", "")))

    doi = ""
    cid = str(citation.get("id", ""))
    if cid.startswith("doi:"):
        doi = cid.removeprefix("doi:").strip()
    url = str(citation.get("link", "")).strip()
    if doi:
        url = f"https://doi.org/{doi}"

    fields: list[tuple[str, str]] = [
        ("title", title),
        ("author", author_str),
        ("journal", journal),
        ("year", year),
    ]
    if doi:
        fields.append(("doi", _bib_escape(doi)))
    if url:
        fields.append(("url", _bib_escape(url)))

    body = ",\n".join(f"  {k} = {{{v}}}" for k, v in fields if v)
    return f"@article{{{key},\n{body}\n}}\n"


def export(*, citations_path: Path, out_path: Path) -> int:
    if not citations_path.exists():
        raise SystemExit(f"Missing citations file: {citations_path}")

    data = yaml.safe_load(citations_path.read_text(encoding="utf-8")) or []
    if not isinstance(data, list):
        raise SystemExit(f"Unexpected citations format (expected list): {citations_path}")

    out_path.parent.mkdir(parents=True, exist_ok=True)
    header = (
        "% This file is generated from `_data/citations.yaml`.\n"
        "% Regenerate with:\n"
        "%   python tools/export_citations_bibtex.py\n\n"
    )
    bib = header + "".join(_to_bibtex(item) for item in data if isinstance(item, dict))
    out_path.write_text(bib, encoding="utf-8")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--citations",
        default=str(REPO_ROOT / "_data" / "citations.yaml"),
        help="Path to citations YAML (default: _data/citations.yaml).",
    )
    parser.add_argument(
        "--out",
        default=str(REPO_ROOT / "downloads" / "publications.bib"),
        help="Output BibTeX path (default: downloads/publications.bib).",
    )
    args = parser.parse_args()
    return export(citations_path=Path(args.citations), out_path=Path(args.out))


if __name__ == "__main__":
    raise SystemExit(main())
